# Copyright 2023 DeepMind Technologies Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Class for evaluating programs proposed by the Sampler."""
import ast
from collections.abc import Sequence
import copy
from typing import Any
import os
import matplotlib.pyplot as plt
from datetime import datetime
import inspect

import code_manipulation
import programs_database
import sandbox


class _FunctionLineVisitor(ast.NodeVisitor):
  """Visitor that finds the last line number of a function with a given name."""

  def __init__(self, target_function_name: str) -> None:
    self._target_function_name: str = target_function_name
    self._function_end_line: int | None = None

  def visit_FunctionDef(self, node: Any) -> None:  # pylint: disable=invalid-name
    """Collects the end line number of the target function."""
    if node.name == self._target_function_name:
      self._function_end_line = node.end_lineno
    self.generic_visit(node)

  @property
  def function_end_line(self) -> int:
    """Line number of the final line of function `target_function_name`."""
    assert self._function_end_line is not None  # Check internal correctness.
    return self._function_end_line


def _trim_function_body(generated_code: str) -> str:
  """Extracts the body of the generated function, trimming anything after it."""
  if not generated_code:
    return ''
  code = f'def fake_function_header():\n{generated_code}'
  tree = None
  # We keep trying and deleting code from the end until the parser succeeds.
  while tree is None:
    try:
      tree = ast.parse(code)
    except SyntaxError as e:
      code = '\n'.join(code.splitlines()[:e.lineno - 1])
  if not code:
    # Nothing could be saved from `generated_code`
    return ''

  visitor = _FunctionLineVisitor('fake_function_header')
  visitor.visit(tree)
  body_lines = code.splitlines()[1:visitor.function_end_line]
  return '\n'.join(body_lines) + '\n\n'


def _sample_to_program(
    generated_code: str,
    version_generated: int | None,
    template: code_manipulation.Program,
    function_to_evolve: str,
) -> tuple[code_manipulation.Function, str]:
  """Returns the compiled generated function and the full runnable program."""
  body = _trim_function_body(generated_code)
  if version_generated is not None:
    body = code_manipulation.rename_function_calls(
        body,
        f'{function_to_evolve}_v{version_generated}',
        function_to_evolve)

  program = copy.deepcopy(template)
  evolved_function = program.get_function(function_to_evolve)
  evolved_function.body = body
  return evolved_function, str(program)


def _calls_ancestor(program: str, function_to_evolve: str) -> bool:
  """Returns whether the generated function is calling an earlier version."""
  for name in code_manipulation.get_functions_called(program):
    # In `program` passed into this function the most recently generated
    # function has already been renamed to `function_to_evolve` (wihout the
    # suffix). Therefore any function call starting with `function_to_evolve_v`
    # is a call to an ancestor function.
    if name.startswith(f'{function_to_evolve}_v'):
      return True
  return False


class Evaluator:
  """Class that analyses functions generated by LLMs."""

  def __init__(
      self,
      database: programs_database.ProgramsDatabase,
      template: code_manipulation.Program,
      function_to_evolve: str,
      function_to_run: str,
      inputs: Sequence[Any],
      timeout_seconds: int = 30,
      sampler = None,
  ):
    self._database = database
    self._template = template
    self._function_to_evolve = function_to_evolve
    self._function_to_run = function_to_run
    self._inputs = inputs
    self._timeout_seconds = timeout_seconds
    self._sandbox = sandbox.GPUSandbox()
    self._best_score = float('-inf')
    self._sampler = sampler
    
    # Create visualizations directory if it doesn't exist
    self._viz_dir = "visualizations"
    os.makedirs(self._viz_dir, exist_ok=True)

  def _save_visualization(self, grid: list[list[int]], grid_size: int, score: float):
    """Save visualization of the grid solution."""
    plt.figure(figsize=(8, 8))
    plt.imshow(grid, cmap='tab10')
    plt.colorbar()
    plt.title(f'L-shape Ramsey Grid {grid_size}x{grid_size}\nScore: {score}')
    
    # Add grid lines
    plt.grid(True, which='both', color='gray', linewidth=0.5)
    plt.xticks(range(grid_size))
    plt.yticks(range(grid_size))
    
    # Create filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"l_shape_grid_{grid_size}x{grid_size}_{timestamp}.png"
    filepath = os.path.join(self._viz_dir, filename)
    
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"Saved visualization to: {filepath}")

  def _extract_grid_from_program(self, program: str) -> list[list[int]]:
    """Extract the grid from a program string."""
    # Create a new namespace for execution
    namespace = {}
    exec(program, namespace)
    
    # Get the function and run it with a test size
    func = namespace.get('solve_l_shape')
    if func:
      # Run the function to get the score
      score = func(4)  # Test with size 4
      if score > 0:  # If it's a valid solution
        # Get the grid from the function's local variables
        if 'grid' in namespace:
          return namespace['grid']
        # If grid is not in namespace, try to get it from the function's locals
        frame = inspect.currentframe()
        while frame:
          if 'grid' in frame.f_locals:
            return frame.f_locals['grid']
          frame = frame.f_back
    return []

  def analyse(
      self,
      sample: str,
      island_id: int | None,
      version_generated: int | None,
  ) -> None:
    """Compiles the sample into a program and executes it on test inputs."""
    new_function, program = _sample_to_program(
        sample, version_generated, self._template, self._function_to_evolve)

    scores_per_test = {}
    for current_input in self._inputs:
      test_output, runs_ok = self._sandbox.run(
          program, self._function_to_run, current_input, self._timeout_seconds)
      if (runs_ok and not _calls_ancestor(program, self._function_to_evolve)
          and test_output is not None):
        if not isinstance(test_output, (int, float)):
          raise ValueError('@function.run did not return an int/float score.')
        scores_per_test[current_input] = test_output
        
        # Update best score if this is better
        if test_output > self._best_score:
          self._best_score = test_output
          print(f"\nNew Best Score Found: {self._best_score}")
          print(f"Grid Size: {current_input}")
          print(f"Program:\n{program}\n")
          
          # Save visualization for the new best solution
          grid = self._extract_grid_from_program(program)
          if grid:
            self._save_visualization(grid, current_input[0], test_output)
          
          # Notify sampler of success
          if self._sampler:
            self._sampler.update_success(test_output)

    if scores_per_test:
      self._database.register_program(new_function, island_id, scores_per_test)
